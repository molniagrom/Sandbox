// В этом ката вы создадите функцию, которая принимает список и возвращает список в обратном порядке.
//
// Примеры (Вход -> Выход)
// * [1, 2, 3, 4] -> [4, 3, 2, 1]
// * [9, 2, 0, 7]  -> [7, 0, 2, 9]
//
// function reverseList(list) {
//     return list.reverse()
// }

//.......................................................................................

// Создайте функцию, которая принимает строку и один символ и возвращает целое число — количество вхождений второго аргумента в первый.
//
// 0Если не удалось найти ни одного вхождения, следует вернуть количество.
//
// ("Hello", 'o') => 1
// ("Hello", 'l')  => 2
// ("", 'z') => 0
// Примечания
// Первый аргумент может быть пустой строкой.
//     В языках, не имеющих отдельного символьного типа данных, второй аргумент будет строкой длины 1.

// function strCount(str, letter) {
//     // Инициализация счётчика
//     let count = 0;
//
//     // Перебор каждого символа в строке
//     for (let i = 0; i < str.length; i++) {
//         // Сравнение символов
//         if (str[i] === letter) {
//             count++; // Увеличиваем счётчик при совпадении
//         }
//     }
//
//     // Возвращаем количество вхождений
//     return count;
// }

//......................................................................................

// вычислить квадрат числа

// function square(num) {
//     return num * num;
// }

// ............................................................................................

// Эта функция должна проверять, factor является ли множителем base.
//
// Вернитесь true, является ли это фактором или false нет.
//
// О факторах
// Множители — это числа, которые можно перемножить, чтобы получить другое число.
//
// 2 и 3 являются множителями 6, потому что:2 * 3 = 6
//
// Вы можете найти множитель, разделив числа. Если остаток равен 0, то число является множителем.
// В большинстве языков можно использовать оператор mod (%) для проверки остатка.
// Например, 2 не является множителем числа 7, потому что:7 % 2 = 1
//
// Примечание: base — не отрицательное число, factor — положительное число.

// function checkForFactor(base, factor) {
//     // Проверяем, является ли factor множителем base
//     return base % factor === 0;
// }

// ........................................................................................................

// Дан массив целых чисел, удалить наименьшее значение. Не изменять исходный массив/список. Если есть несколько элементов с одинаковым значением, удалить элемент с наименьшим индексом. Если вы получили пустой массив/список, вернуть пустой массив/список.
//
// Не меняйте порядок оставшихся элементов.
//
// Примеры
// * Input: [1,2,3,4,5], output = [2,3,4,5]
// * Input: [5,3,2,1,4], output = [5,3,2,4]
// * Input: [2,2,1,2,1], output = [2,2,2,1]

// function removeSmallest(numbers) {
//     // Если массив пустой, возвращаем пустой массив
//     if (numbers.length === 0) return [];
//
//     // Находим индекс наименьшего элемента
//     let minIndex = 0;
//     for (let i = 1; i < numbers.length; i++) {
//         if (numbers[i] < numbers[minIndex]) {
//             minIndex = i;
//         }
//     }
//
//     // Создаем новый массив, исключая элемент с наименьшим индексом
//     return numbers.filter((_, index) => index !== minIndex);
// }

// ................................................................

// Вам дан массив целых чисел нечетной длины , в котором все числа одинаковы, за исключением одного числа.
// Завершите метод, который принимает такой массив и возвращает это единственное отличающееся число.
// Входной массив всегда будет действителен! (нечетная длина >= 3)

// Примеры
// [1, 1, 2] ==> 2
// [17, 17, 3, 17, 17, 17, 17] ==> 3

// function stray(numbers) {
//   return numbers.find((num) => numbers.filter((n) => n === num).length === 1);
// }

// ***

// function stray(numbers) {
//     const count = {};  // Создаём объект для хранения количества вхождений

//     // Проходим по массиву и подсчитываем количество каждого числа
//     numbers.forEach(num => {
//       count[num] = (count[num] || 0) + 1;  // Увеличиваем счётчик в объекте
//     });

//     // Проходим по объекту и находим число с вхождением 1
//     for (let key in count) {
//       if (count[key] === 1) {
//         return Number(key);  // Возвращаем найденное число
//       }
//     }
//   }
//   ..........................................................................

// Напишите функцию для преобразования имени в инициалы. Эта ката строго принимает два слова с одним пробелом между ними.
// Вывод должен состоять из двух заглавных букв, разделенных точкой
// Это должно выглядеть так:

// Sam Harris=>S.H
// patrick feeney=>P.F

// function abbrevName(name) {
//   // Разделяем имя на слова
//   const parts = name.split(" ");
//   // Берем первую букву каждого слова, приводим к верхнему регистру и соединяем с точкой
//   return `${parts[0][0].toUpperCase()}.${parts[1][0].toUpperCase()}`;
// }

// .........................................................................................

// Дана строка цифр, вам следует заменить любую цифру ниже 5 на '0', а любую цифру 5 и выше на '1'. Верните полученную строку.
// Примечание: ввод никогда не будет пустой строкой.

// function fakeBin(x) {
//     let result = '';
//     for (let i = 0; i < x.length; i++) {
//         result += (x[i] < '5' ? '0' : '1'); // Заменяем цифры
//     }
//     return result;
// }

// ****

// function fakeBin(x) {
//     return x
// .split('') // Разделяем строку на массив символов
// .map(num => (num < '5' ? '0' : '1')) // Заменяем цифры
// .join(''); // Соединяем обратно в строку
// }

// ...................................................................................................

// Даны три целых числа a, b, и c, вернуть наибольшее число, полученное после вставки операторов +, *, и скобок (). Другими словами, попробовать каждую комбинацию a, b, и cс операторами, не переупорядочивая операнды, и вернуть максимальное значение.

// Пример
// Вот несколько возможных выражений с числами 1, 2 и 3:

// 1 * (2 + 3) = 5
// 1 * 2 * 3 = 6
// 1 + 2 * 3 = 7
// (1 + 2) * 3 = 9
// Максимальное значение, которое можно получить, — 9.

// Примечания
// Числа всегда положительные и находятся в диапазоне 1 ≤ a, b, c ≤ 10.
// Одну и ту же операцию можно использовать несколько раз.
// Нет необходимости использовать все операторы и скобки.
// Вы не можете поменять операнды местами. Например, с данными числами вы не можете получить выражение (1 + 3) * 2 = 8.

// function expressionMatter(a, b, c) {
//     // Вычисляем все возможные выражения
//     const results = [
//       a + b + c,
//       a * b * c,
//       a + b * c,
//       a * b + c,
//       (a + b) + c,
//       (a * b) * c,
//       a + (b + c),
//       a * (b * c),
//       (a + b) * c,
//       a * (b + c),
//     ];

//     // Возвращаем максимальное значение
//     return Math.max(...results);
//   }

// ..........................................................................................

// Создайте функцию, которая shortcutудаляет строчные гласные ( a, e, i, o, u) в заданной строке.

// Примеры
// "hello"     -->  "hll"
// "codewars"  -->  "cdwrs"
// "goodbye"   -->  "gdby"
// "HELLO"     -->  "HELLO"
// не беспокойтесь о заглавных гласных
// yне считается гласной для этой ката

// function shortcut(string) {
//     return string
//             .split('') // Разделяем строку на массив символов
//             .map(char => {
//               // Заменяем строчные гласные на пустую строку
//               if ('aeiou'.includes(char)) {
//                 return ''; // Если символ - гласная, заменяем на пустую строку
//               }
//               return char; // Если не гласная, возвращаем символ
//             })
//             .join(''); // Соединяем обратно в строку
//   }

// ***

// function shortcut(string) {
//     return string.replace(/[aeiou]/g, '');
//   }

// ..................................................................................................................

// Даны два целых числа aи b, которые могут быть положительными или отрицательными, найдите сумму всех целых чисел между ними и включая их и верните ее. Если два числа равны, верните aили b.

// Примечание: a и bне заказываются!

// Примеры (a, b) -> вывод (объяснение)
// (1, 0) --> 1 (1 + 0 = 1)
// (1, 2) --> 3 (1 + 2 = 3)
// (0, 1) --> 1 (0 + 1 = 1)
// (1, 1) --> 1 (1 since both are same)
// (-1, 0) --> -1 (-1 + 0 = -1)
// (-1, 2) --> 2 (-1 + 0 + 1 + 2 = 2)
// Ваша функция должна возвращать только число, а не объяснение того, как вы это число получили.

// function getSum(a, b) {
//     let sum = 0;
//     const start = Math.min(a, b);
//     const end = Math.max(a, b);

//     for (let i = start; i <= end; i++) {
//         sum += i;
//     }

//     return sum;
// }

// ..............................................................................................

// Банкоматы допускают использование 4- или 6-значных PIN-кодов, которые не могут содержать ничего, кроме 4 или 6 цифр.
// Если функции передана допустимая строка PIN-кода, вернуть true, в противном случае вернуть false.

// Примеры ( Вход -> Выход)
// "1234"   -->  true
// "12345"  -->  false
// "a234"   -->  false

// function validatePIN(pin) {
//     // Проверяем, что длина PIN-кода равна 4 или 6, и все символы - цифры
//     return (pin.length === 4 || pin.length === 6) && /^\d+$/.test(pin);
// }

// объяснение

// pin.length === 4 || pin.length === 6

// Что происходит здесь: Мы проверяем, что длина строки pin составляет либо 4, либо 6 символов. Если длина другая, выражение сразу станет false, и функция вернёт false.

// /^\d+$/.test(pin)

//  Это регулярное выражение, которое проверяет, что строка состоит только из цифр. Вот его разбор:

// ^: Обозначает начало строки.
// \d: Обозначает одну цифру (это любой символ от '0' до '9').
// +: Указывает, что таких цифр должно быть одна или более.
// $: Обозначает конец строки.
// Что проверяет это регулярное выражение:

// Строка должна начинаться с цифры (^).
// Все символы в строке должны быть цифрами (\d+).
// Строка должна заканчиваться цифрой ($). То есть строка целиком должна состоять из одной или более цифр и не содержать других символов (например, букв или пробелов).
// .test(pin): Метод .test() используется для проверки строки на соответствие регулярному выражению. Если строка pin полностью состоит из цифр, метод вернёт true; если содержит что-то другое (например, буквы или символы), он вернёт false.

// Логическое И: &&
// && (логическое И): Этот оператор объединяет две части выражения:
// Проверку длины PIN-кода.
// Проверку, что все символы — цифры.
// Оператор && возвращает true, только если обе части выражения истинны. Если хотя бы одна часть false, итоговый результат также будет false.

// ***

// function validatePIN(pin) {
//   // Проверяем длину PIN-кода
//   if (pin.length !== 4 && pin.length !== 6) {
//     return false;
//   }

//   // Проверяем, что все символы являются цифрами
//   for (let i = 0; i < pin.length; i++) {
//     if (pin[i] < "0" || pin[i] > "9") {
//       return false;
//     }
//   }

//   return true;
// }

// ......................................................................................................................

// Анаграмма — это результат перестановки букв слова для получения нового слова (см. Википедию ).
// Примечание: анаграммы нечувствительны к регистру.
// Завершите функцию возврата true, если два аргумента являются анаграммами друг друга; falseв противном случае возвратите значение.

// var isAnagram = function(test, original) {

//     test = test.toLowerCase();
//     original = original.toLowerCase();

//     let sortedTest = test.split('').sort().join('');
//     let sortedOriginal = original.split('').sort().join('');

//     return sortedTest === sortedOriginal;
// };

// ..............................................................................................................

// Дополните функцию так, чтобы она находила среднее значение трех переданных ей оценок и возвращала буквенное значение, связанное с этой оценкой.

// Числовая оценка	Буквенная оценка
// 90 <= оценка <= 100	«А»
// 80 <= оценка < 90	«Б»
// 70 <= оценка < 80	'С'
// 60 <= оценка < 70	'Д'
// 0 <= оценка < 60	'Ф'
// Все проверенные значения находятся в диапазоне от 0 до 100. Нет необходимости проверять наличие отрицательных значений или значений больше 100.

// function getGrade(s1, s2, s3) {

//     let averageValue = (s1 + s2 + s3) / 3;

//  if (averageValue >= 90 && averageValue <= 100) {
//     return "A";
//   } else if (averageValue >= 80 && averageValue < 90) {
//     return "B";
//   } else if (averageValue >= 70 && averageValue < 80) {
//     return "C";
//   } else if (averageValue >= 60 && averageValue < 70) {
//     return "D";
//   } else {
//     return "F";
//   }
// }

// ...............................................................................................................................

// Напишите программу, которая находит сумму каждого числа от 1 до num. Число всегда будет положительным целым числом больше 0. Вашей функции нужно только вернуть результат, то, что показано в скобках в примере ниже, — это то, как вы достигаете этого результата, и это не его часть, см. примеры тестов.
// Например (Вход -> Выход) :

// 2 -> 3 (1 + 2)
// 8 -> 36 (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8)

// var summation = function (num) {
//   let result = 0;
//   for (let i = 1; i <= num; i++) {
//     result += i;
//   }
//   return result;
// };

// ..................................................................................................................................

// Задача
// Я написал пять функций. Каждая функция получает параметр arr, который является массивом. Завершите функции, используя arrвнутри тел функций.

// 1. getLength(arr)    should return length of arr
// 2. getFirst(arr)     should return the first element of arr
// 3. getLast(arr)      should return the last element of arr
// 4. pushElement(arr)  should push an element to arr, and then return arr
// 5. popElement(arr)   should pop an element from arr, and then return arr
// Закончив работу, нажмите «Выполнить тесты», чтобы проверить, правильно ли работает ваш код.

// В конце нажмите «Отправить», чтобы отправить свой код для прохождения этого ката.

// function getLength(arr){
//   //return length of arr
//   return arr.length;
// }
// function getFirst(arr){
//   //return the first element of arr
//   return arr[0];
// }
// function getLast(arr){
//   //return the last element of arr
//   return arr[arr.length-1];
// }
// function pushElement(arr){
//   var el=4;
//   //push el to arr
//   arr.push(el);
//   return arr;
// }
// function popElement(arr){
//   //pop an element from arr
//   arr.pop();
//   return arr;
// }

// ......................................................................................

// Ваша функция принимает два аргумента:
// возраст нынешнего отца (лет)
// текущий возраст его сына (лет)
// Вычислите, сколько лет назад отец был вдвое старше своего сына (или через сколько лет он будет вдвое старше). Ответ всегда больше или равен 0, независимо от того, было ли это в прошлом или в будущем.

// function twiceAsOld(dadYearsOld, sonYearsOld) {
//   return Math.abs(dadYearsOld - 2 * sonYearsOld);
// }

// Нам нужно определить разницу между возрастом отца и удвоенным возрастом сына. Это покажет, сколько лет прошло (или сколько осталось) до того момента, когда отец был в два раза старше сына.
// Например, если отец сейчас 40 лет, а сыну — 10 лет, то когда-то отец был (или будет) вдвое старше сына, то есть ему было (или будет) 20 лет, когда сыну было (или будет) 10 лет.
// Формула:

// Нам нужно найти разницу между возрастом отца и удвоенным возрастом сына:
// разница = dadYearsOld - 2 × sonYearsOld

// разница=dadYearsOld−2×sonYearsOld
// Если эта разница положительная, значит, это событие произошло в прошлом. Если отрицательная — оно произойдёт в будущем.
// Возвращаем абсолютное значение:

// Нам важно только количество лет, поэтому мы берём абсолютное значение (всегда положительное):
// ответ = ∣ dadYearsOld − 2 × sonYearsOld ∣

// Таким образом, мы получаем, сколько лет назад или через сколько лет отец был или будет вдвое старше.

// ....................................................................................

// Вы спрашиваете маленькую девочку: «Сколько тебе лет?» Она всегда отвечает: «x лет», где x — случайное число от 0 до 9.
// Напишите программу, которая возвращает возраст девочки (0-9) в виде целого числа.
// Предположим, что тестовая входная строка всегда является допустимой строкой. Например, тестовая входная строка может быть "1 year old" или "5 years old". Первый символ в строке всегда является числом.

// function getAge(inputString) {
//   return parseInt(inputString[0], 10);
// }
// ........................................................................................................................................................

// Полная функция saleHotdogs/ SaleHotDogs/ sale_hotdogs, функция принимает 1 параметр: n, n — количество хотдогов, которое купит клиент, разные числа имеют разные цены (см. следующую таблицу), возвращает сумму, которую клиент потратит на покупку этого количества хотдогов.

// количество хот-догов	цена за единицу (центы)
// п < 5	100
// n >= 5 и n < 10	95
// п >= 10	90

// function saleHotdogs(n){
//   return n < 5 ? n * 100 : n < 10 ? n * 95 : n * 90;
// }

// ***

// function saleHotdogs(n) {
//   if (n < 5) {
//     return n * 100;
//   } else if (n < 10) {
//     return n * 95;
//   } else {
//     return n * 90;
//   }
// }

//...............................................................................................

// Завершите функцию howManydays. Она принимает 1 параметр month, что означает месяц года. Разные месяцы имеют разное количество дней, как показано в таблице ниже. Верните количество дней, которые находятся в month. Нет необходимости в проверке входных данных: месяц всегда будет больше 0 и меньше или равен 12.

// function howManydays(month) {
//   var days;
//   switch (month) {
//     case 1:
//     case 3:
//     case 5:
//     case 7:
//     case 8:
//     case 10:
//     case 12:
//       days = 31;
//       break;
//     case 4:
//     case 6:
//     case 9:
//     case 11:
//       days = 30;
//       break;
//     case 2:
//       days = 28;
//       break;
//     default:
//       days = 0; // на всякий случай, но эта строка не потребуется, так как вход всегда будет между 1 и 12
//   }
//   return days;
// }

// ...............................................................................................

// Создайте боевую функцию, которая берет текущее здоровье игрока и количество полученного урона, и возвращает новое здоровье игрока. Здоровье не может быть меньше 0 .

// function combat(health, damage) {
//   const newHealth = health - damage;
//    return newHealth > 0 ? newHealth : 0;
//  }

//  .....................................................................................................

// Вам необходимо написать функцию, которая принимает три параметра:

// cap количество людей, которое может вместить автобус, не считая водителя.
// on количество людей в автобусе, не считая водителя.
// wait количество людей, ожидающих посадки в автобус, не считая водителя.
// Если места достаточно, вернуть 0, а если нет, вернуть количество пассажиров, которых он не может взять.

// function enough(cap, on, wait) {
//   const vacantSeats = cap - on;

//   if (vacantSeats >= wait) {
//     return 0;
//   } else {
//     return wait - vacantSeats;
//   }
// }

// ***

// function enough(cap, on, wait) {
//   return Math.max(wait + on - cap, 0);
// }

// ...................................................................................................

// Если в качестве входных данных задано целое число, можно ли округлить его до ближайшего (то есть «больше или равно») кратного 5 числа?

// Примеры:

// input:    output:
// 0    ->   0
// 2    ->   5
// 3    ->   5
// 12   ->   15
// 21   ->   25
// 30   ->   30
// -2   ->   0
// -5   ->   -5
// etc.
// Входными данными могут быть любые положительные или отрицательные целые числа (включая 0).

// Можно предположить, что все входные данные являются допустимыми целыми числами.

// function roundToNext5(n) {
//   while (n % 5 !== 0) {
//     n++;
//   }
//   return n;
// }

// ***

// function roundToNext5(n) {
//   return Math.ceil(n / 5) * 5;
// }

// ............................................................................................................................................................

// В некоторых языках сценариев, таких как PHP, существует логический оператор (например &&, ||, and, , or, и т. д.), называемый «Исключающее ИЛИ» (отсюда и название этого Ката). Исключающее ИЛИ оценивает два булевых значения. Затем он возвращает, trueесли только одно из двух выражений истинно , falseв противном случае. Например:

// false xor false == false // since both are false
// true xor false == true // exactly one of the two expressions are true
// false xor true == true // exactly one of the two expressions are true
// true xor true == false // Both are true.  "xor" only returns true if EXACTLY one of the two expressions evaluate to true.
// Задача
// Поскольку мы не можем определять ключевые слова в Javascript (ну, по крайней мере, я не знаю, как это сделать), ваша задача — определить функцию, xor(a, b)где aи b— два выражения, которые нужно оценить. Ваша xorфункция должна иметь поведение, описанное выше, возвращая , trueесли только одно из двух выражений оценивается как true , falseв противном случае.

// function xor(a, b) {
//   return a !== b;
// }
// a !== b — Оператор строгого неравенства !== сравнивает два значения. Он возвращает true, если a и b имеют разные значения, и false, если они одинаковы.
// ...................................................................

// Создать программу, которая будет принимать два списка целых чисел, aи b. Каждый список будет состоять из 3 положительных целых чисел больше 0, представляющих размеры прямоугольных параллелепипедов aи b. Вы должны найти разницу объемов прямоугольных параллелепипедов независимо от того, какой из них больше.
// Например, если переданы параметры ([2, 2, 3], [5, 4, 1]), то громкость aравна 12, а громкость bравна 20. Следовательно, функция должна вернуть 8.

// // function findDifference(a, b) {
//   // Вычисляем объем первого параллелепипеда
//   const volumeA = a[0] * a[1] * a[2];

//   // Вычисляем объем второго параллелепипеда
//   const volumeB = b[0] * b[1] * b[2];

//   // Возвращаем абсолютную разницу между объемами
//   return Math.abs(volumeA - volumeB);
// }

// ****

// const findDifference = (a, b) => Math.abs(a[0] * a[1] * a[2] - b[0] * b[1] * b[2]);

// Ваша задача — написать функцию, которая принимает строку и возвращает новую строку, в которой удалены все гласные.
// Например, строка «Этот сайт для неудачников LOL!» превратится в «Ths wbst s fr lsrs LL!».
// Примечание: в данном случае ката yне считается гласной.

// function disemvowel(str) {
//   return str.replace(/[aeiouAEIOU]/g, '');}

// ...........................................................................

// Таракан — одно из самых быстрых насекомых. Напишите функцию, которая берет его скорость в км в час и возвращает ее в см в секунду, округленную до целого числа (= floored).

// Например:

// 1.08 --> 30
// Примечание! Входные данные — вещественное число (фактический тип зависит от языка) и >= 0. Результатом должно быть целое число.

// function cockroachSpeed(s) {
//   return Math.floor((s * 100000) / 3600);
// }

// ............................................................................................................................

// Реализуйте функцию, которая принимает 3 целочисленных значения a, b, c. Функция должна возвращать true, если треугольник может быть построен со сторонами заданной длины, и false в любом другом случае.

// (В этом случае все треугольники должны иметь поверхность больше 0, чтобы быть принятыми).

// Примеры:

// Input -> Output
// 1,2,2 -> true
// 4,2,3 -> true
// 2,2,2 -> true
// 1,2,3 -> false
// -5,1,3 -> false
// 0,2,3 -> false
// 1,2,9 -> false

// я сама написала...)))
// function isTriangle(a, b, c) {
//   if (a + b > c && a + c > b && b + c > a) {
//     if (a || b || c > 0) {
//       return true;
//     } else {
//       return false;
//     }
//   } else {
//     return false;
//   }
// }

// ***
// function isTriangle(a,b,c){
//    return a + b > c && a + c > b && c + b > a;
// }

// .......................................................................................................

// Возьмите массив и удалите каждый второй элемент из массива. Всегда сохраняйте первый элемент и начинайте удаление со следующего элемента.
// Пример:
// ["Keep", "Remove", "Keep", "Remove", "Keep", ...]-->["Keep", "Keep", "Keep", ...]
// Ни один из массивов не будет пустым, так что вам не о чем беспокоиться!

// function removeEveryOther(arr){
//   let newArr = [];
//   for (let i = 0; i < arr.length; i++) {
//     if(i % 2 === 0){
//       newArr.push(arr[i])
//     }
//   }
//   return newArr;
// }

// ............................................................................................................

// Вам нужно написать функцию, которая переворачивает слова в заданной строке. Слова всегда разделяются одним пробелом.
// Поскольку входные данные могут содержать конечные пробелы, вам также придется игнорировать ненужные пробелы.
// Пример ( Вход -> Выход )

// "Hello World" --> "World Hello"
// "Hi There." --> "There. Hi"

// function reverse(string) {
//   // Удаляем лишние пробелы и разбиваем строку на слова
//   const words = string.trim().replace(/\s+/g, " ").split(" ");

//   // Переворачиваем массив слов
//   const reversedWords = words.reverse();

//   // Объединяем слова обратно в строку
//   return reversedWords.join(" ");
// }

// .............................................................................

// Напишите функцию для разбиения строки и преобразования ее в массив слов.
// Примеры (Вход ==> Выход):
// "Robin Singh" ==> ["Robin", "Singh"]

// "I love arrays they are my favorite" ==> ["I", "love", "arrays", "they", "are", "my", "favorite"]

// Я сама написала
// function stringToArray(string) {
//   return string.split(" ");
// }
// ................................................................................................

// Если в имени ровно 4 буквы, то это точно ваш друг! В противном случае, будьте уверены, это не...

// Input = {"Ryan", "Kieran", "Jason", "Yous"}
// Output = {"Ryan", "Yous"}

// Input = {"Peter", "Stephen", "Joe"}
// Output = {}
// Входные строки будут содержать только буквы. Примечание: сохраните исходный порядок имен в выходных данных.

//я сама
// function friend(friends) {
//   const result = friends.filter((friend) => friend.length === 4);
//   return result;
// }

// ....................................................................................

// В большом городе настало время бонусов! Толстокровые потирают лапки в предвкушении... но кто заработает больше всего денег?
// Создайте функцию, которая принимает два аргумента (зарплата, премия). Зарплата будет целым числом, а премия — логическим.
// Если бонус — правда, зарплату следует умножить на 10. Если бонус — ложь, то толстосум не заработал достаточно денег и должен получить только свою заявленную зарплату.
// Возвращает общую сумму, которую получит пользователь, в виде строки с префиксом «£» (= "\u00A3", JS, Go, Java, Scala и Julia), «$» (C#, C++, Dart, Ruby, Clojure, Elixir, PHP, Python, Haskell и Lua) или «¥» (Rust).

// function bonusTime(salary, bonus) {
//   if (bonus === true) {
//     return "£" + salary * 10;
//   } else {
//     return "£" + salary;
//   }
// }

// .................................................................................................

// Получив букву, верните ее положение в алфавите.
// Ввод :: "а"
// Вывод :: "Позиция алфавита: 1"
// Примечание: проверяются только строчные буквы английского языка.
//В JavaScript есть способ получить числовое представление символа с помощью метода .charCodeAt()

// function position(letter) {
//   let letterNum = letter.charCodeAt() - 97 + 1;
//   return `Position of alphabet: ${letterNum}`;
// }

// .....................................................................................

// Учитывая строку, необходимо вернуть строку, в которой каждый символ (с учетом регистра) повторяется один раз.

// Примеры (Вход -> Выход):
// * "String"      -> "SSttrriinngg"
// * "Hello World" -> "HHeelllloo  WWoorrlldd"
// * "1234!_ "     -> "11223344!!__  "

// function doubleChar(str) {
//   let str2 = "";
//   for (let i = 0; i < str.length; i++) {
//     str2 += str[i] + str[i];
//   }
//   return str2;
// }

// .............................................................................................

// Учитывая список уникальных numbersэлементов, отсортированных по возрастанию, вернуть новый список так, чтобы значения увеличивались на 1 для каждого индекса от минимального значения до максимального значения (оба включены).

// Пример
// Input:  1,3,5,6,7,8 Output: 1,2,3,4,5,6,7,8

// function pipeFix(numbers) {
//   let max = Math.max(...numbers);
//   let min = Math.min(...numbers);

//   let fixedArray = [];
//   for (let i = min; i <= max; i++) {
//     fixedArray.push(i);
//   }
//   return fixedArray;
// }

// .............................................................................................

// Создайте метод, который позволит проверить, состоит ли строка ВСЕХ ЗАГЛАВНЫХ букв.

// Примеры (вход -> выход)
// "c" -> False
// "C" -> True
// "hello I AM DONALD" -> False
// "HELLO I AM DONALD" -> True
// "ACSKLDFJSgSKLDFJSKLDFJ" -> False
// "ACSKLDFJSGSKLDFJSKLDFJ" -> True
// В этом ката считается, что строка набрана ВСЕМИ ЗАГЛАВНЫМИ БУКВАМИ, если она не содержит ни одной строчной буквы, поэтому любая строка, не содержащая вообще ни одной буквы, тривиально считается набранной ВСЕМИ ЗАГЛАВНЫМИ БУКВАМИ.

// String.prototype.isUpperCase = function () {
//   if (this.length === 0) {
//     return true;
//   }
//   for (let i = 0; i < this.length; i++) {
//     if (this[i] !== this[i].toUpperCase()) {
//       return false;
//     }
//   }
//   return true;
// };

// ***
// String.prototype.isUpperCase=function() {return this==this.toUpperCase()}

// .....................................................................................................

// Подумайте о способе хранения языков в виде базы данных. Языки перечислены ниже, так что вы можете копировать и вставлять!
// Напишите функцию 'welcome', которая принимает параметр 'language' с типом Stringи возвращает приветствие - если оно есть в вашей базе данных. По умолчанию она должна быть на английском языке, если язык отсутствует в базе данных или в случае недопустимого ввода.
// База данных
// Пожалуйста, измените это в соответствии с вашим языком.
// Возможные недействительные входные данные включают в себя:

// IP_ADDRESS_INVALID - not a valid ipv4 or ipv6 ip address
// IP_ADDRESS_NOT_FOUND - ip address not in the database
// IP_ADDRESS_REQUIRED - no ip address was supplied

// function greet(language) {
//   let base = [
//     ["english", "Welcome"],
//     ["czech", "Vitejte"],
//     ["danish", "Velkomst"],
//     ["dutch", "Welkom"],
//     ["estonian", "Tere tulemast"],
//     ["finnish", "Tervetuloa"],
//     ["flemish", "Welgekomen"],
//     ["french", "Bienvenue"],
//     ["german", "Willkommen"],
//     ["irish", "Failte"],
//     ["italian", "Benvenuto"],
//     ["latvian", "Gaidits"],
//     ["lithuanian", "Laukiamas"],
//     ["polish", "Witamy"],
//     ["spanish", "Bienvenido"],
//     ["swedish", "Valkommen"],
//     ["welsh", "Croeso"],
//   ];

//   let lang = base.find((item) => item[0] === language);
//   if (lang) {
//     return lang[1];
//   } else {
//     return "Welcome";
//   }
// }

// ..................................................................................

// Напишите функцию, которая всегда возвращает5
// Звучит просто, не правда ли? Просто имейте в виду, что вы не можете использовать ни один из следующих символов:0123456789*+-/

// function unusualFive() {
//   let str = "abcde";
//   return str.length;
// }

// .....................................................................................

// Нам нужна простая функция, которая определяет, нужно ли использовать множественное число или нет. Она должна принимать число и возвращать true, если нужно использовать множественное число с этим числом, или false, если нет. Это было бы полезно при выводе строки, например 5 minutes, 14 apples, или 1 sun.
// Вам нужно беспокоиться только о правилах английской грамматики для этого ката, где все, что не стоит в единственном числе (одно из чего-либо), стоит во множественном числе (не одно из чего-либо).
// Все значения будут положительными целыми числами или числами с плавающей точкой, либо нулем.

// Я НАПИСАЛА САМА СПЕРВОГО РАЗА!!!!!!
// function plural(n) {
//   if (n === 1) {
//     return false;
//   } else {
//     return true;
//   }
// }

// .................................................................................................................................

// Дети пьют пунш.
// Подростки пьют кока-колу.
// Молодежь пьет пиво.
// Взрослые пьют виски.
// Создайте функцию, которая получает возраст и возвращает то, что они пьют.

// Правила:

// Дети до 14 лет.
// Подростки до 18 лет.
// Молодежь до 21 года.
// У взрослых их 21 и более.

// function peopleWithAgeDrink(old) {
//     if (old <= 13) {
//         return "drink toddy";
//     } else if (old <= 17) {
//         return "drink coke";
//     } else if (old >= 18 && old <= 20) {
//         return "drink beer";
//     } else if (old >= 21) {
//         return "drink whisky";
//     }
// }

// ***

// ....................................................................................

// Числа, заканчивающиеся на нули, скучны.
// В вашем мире они могут быть забавными, но не здесь.
// Избавьтесь от них. Оставьте только конечные.
// 1450 -> 145
// 960000 -> 96
// 1050 -> 105
// -1050 -> -105

// function noBoringZeros(n) {
//   if (n === 0) {
//     return 0;
//   }
//   let str = n.toString();
//   let strNew = str.replace(/0*$/, "");
//   let num = Number(strNew);
//   return strNew === "" ? 0 : Number(strNew);
// }
// ***
// function noBoringZeros(n) {
//   while(n % 10 == 0 && n != 0) {
//     n /= 10;
//   }
//   return n;
// }
// ............................................................................

// Дополните решение так, чтобы оно перевернуло все слова в переданной строке.

// Слова разделяются ровно одним пробелом, начальные и конечные пробелы отсутствуют.

// Пример (Вход -> Выход):

// "The greatest victory is that which requires no battle" --> "battle no requires which that is victory greatest The"

// function reverseWords(str) {
//   let words = str.split(" ");
//   let reverse = words.reverse();
//   let join = reverse.join(" ");
//   return join;
// }

// ............................................................................................

// Вам даны два отсортированных массива, которые оба содержат только целые числа. Ваша задача — найти способ объединить их в один, отсортированный в порядке возрастания. Завершите функцию mergeArrays(arr1, arr2), где arr1 и arr2 — исходные отсортированные массивы.

// Вам не нужно беспокоиться о проверке, так как arr1 и arr2 должны быть массивами с 0 или более целыми числами. Если оба arr1 и arr2 пусты, то просто верните пустой массив.

// Примечание: arr1 и arr2 могут быть отсортированы в разных порядках. Также arr1 и arr2 могут иметь одинаковые целые числа. Удалите дубликаты в возвращаемом результате.

// Примеры (вход -> выход)
// * [1, 2, 3, 4, 5], [6, 7, 8, 9, 10] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// * [1, 3, 5, 7, 9], [10, 8, 6, 4, 2] -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

// * [1, 3, 5, 7, 9, 11, 12], [1, 2, 3, 4, 5, 10, 12] -> [1, 2, 3, 4, 5, 7, 9, 10, 11, 12]

// function mergeArrays(arr1, arr2) {
//   const newArray = [].concat(arr1, arr2);
//   let newSet = [...new Set(newArray)];
//   newSet.sort((a, b) => a - b);
//   return newSet;
// }

// .......................................................................................................

//Создайте функцию, которая всегда возвращает True/ trueдля каждого элемента в данном списке.
// Однако, если элемент — это слово 'flick' , переключитесь на то, чтобы всегда возвращать противоположное логическое значение.

// Примеры
// ['codewars', 'flick', 'code', 'wars'] ➞ [True, False, False, False]

// ['flick', 'chocolate', 'adventure', 'sunshine'] ➞ [False, False, False, False]

// ['bicycle', 'jarmony', 'flick', 'sheep', 'flick'] ➞ [True, True, False, False, True]

// function flickSwitch(arr) {
//   let result = [];
//   let bool = true;

//   for (let i = 0; i < arr.length; i++) {
//     if (arr[i] === "flick") {
//       bool = !bool;
//       result[i] = bool;
//     } else {
//       result[i] = bool;
//     }
//   }
//   return result;
// }

// ***

// function flickSwitch(arr){
//   let returning = true;
//     return arr.map( (v) => {
//       return (v === "flick") ? returning = !returning : returning;
//     })
// }

// .........................................................................................

// Завершите функцию, которая преобразует шестнадцатеричное число (заданное в виде строки) в десятичное число.

// function hexToDec(hexString){
//   return parseInt(hexString, 16);
// }

// .................................................................................................

// Напишите функцию, которая будет проверять, являются ли два заданных символа одинаковыми.

// Если какой-либо из символов не является буквой, вернуть-1
// Если оба символа имеют одинаковый регистр, вернуть1
// Если оба символа являются буквами, но не в одном регистре, вернуть0
// Примеры
// 'a'и 'g'возвращается1

// 'A'и 'C'возвращается1

// 'b'и 'G'возвращается0

// 'B'и 'g'возвращается0

// '0'и '?'возвращается-1

// function sameCase(a, b) {
//   if (!a.match(/[a-zA-Z]/) || !b.match(/[a-zA-Z]/)) {
//     return -1;
//   }

//   if (a === a.toUpperCase() && b === b.toUpperCase()) {
//     return 1;
//   } else if (a === a.toLowerCase() && b === b.toLowerCase()) {
//     return 1;
//   } else {
//     return 0;
//   }
// }

// ............................................................................

// Напишите функцию с именем setAlarm/ set_alarm/ set-alarm/ setalarm(в зависимости от языка), которая получает два параметра. Первый параметр, employed, является истинным, когда вы работаете, а второй параметр, vacationявляется истинным, когда вы в отпуске.

// Функция должна возвращать значение true, если вы работаете и не в отпуске (потому что это обстоятельства, при которых вам нужно установить будильник). В противном случае она должна возвращать значение false. Примеры:

// employed | vacation
// true     | true     => false
// true     | false    => true
// false    | true     => false
// false    | false    => false

// function setAlarm(employed, vacation) {
//   if (employed === true && vacation === false) {
//     return true;
//   } else {
//     return false;
//   }
// }

// ...................................................................................

// Широкоротая лягушка особенно интересуется пищевыми привычками других существ.

// Он просто не может перестать спрашивать у существ, с которыми сталкивается, что они любят есть. Но затем он встречает аллигатора, который просто ОБОЖАЕТ есть лягушек с широким ртом!

// Когда он встречает аллигатора, тот делает крошечный рот.

// Ваша цель в этом ката — создать полный mouth_sizeметод, этот метод принимает один аргумент animal, который соответствует животному, с которым столкнулась лягушка. Если это alligator(нечувствительный к регистру) return, smallв противном случае return wide.

// function mouthSize(animal) {
//   let alligator = "alligator";
//    let small  = "small";
//     let wide = "wide";
//   if (animal.toUpperCase() === alligator.toUpperCase()) {
//     return small;
//   } else {
//     return wide;
//   }
// }

// ***

// function mouthSize(animal) {
//   return animal.toLowerCase() === 'alligator' ? 'small' : 'wide';
// }

// ....................................................................................

// Мужские гаметы или сперматозоиды у людей и других млекопитающих гетерогаметны и содержат один из двух типов половых хромосом. Это либо X, либо Y. Женские гаметы или яйцеклетки, однако, содержат только половую хромосому X и являются гомогаметными.

// В этом случае пол особи определяется сперматозоидом. Если сперматозоид, содержащий X-хромосому, оплодотворяет яйцеклетку, то полученная зигота будет XX или женской. Если сперматозоид содержит Y-хромосому, то полученная зигота будет XY или мужской.

// Определите, будет ли пол потомства мужским или женским, на основе хромосомы X или Y, присутствующей в сперме самца.

// Если сперматозоид содержит X-хромосому, вернуть «Поздравляем! У вас будет дочь». Если сперматозоид содержит Y-хромосому, вернуть «Поздравляем! У вас будет сын».

// function chromosomeCheck(sperm) {
// // Приводим sperm к верхнему регистру и убираем лишние пробелы
//   sperm = sperm.trim().toUpperCase();

//   // Проверяем, что sperm является корректной хромосомой
//   if (sperm === "X") {
//     return "Congratulations! You're going to have a daughter.";
//   } else if (sperm === "Y") {
//     return "Congratulations! You're going to have a son.";
//   } else {
//     return "Gender undetermined"; // На случай, если передано что-то другое
//   }
// }

// ...........................................................................................

// Уберите восклицательный знак с конца строки. Для начинающего ката можно предположить, что входные данные всегда являются строкой, нет необходимости ее проверять.

// Примеры
// "Hi!"     ---> "Hi"
// "Hi!!!"   ---> "Hi!!"
// "!Hi"     ---> "!Hi"
// "!Hi!"    ---> "!Hi"
// "Hi! Hi!" ---> "Hi! Hi"
// "Hi"      ---> "Hi"

// function remove(string) {
//   return string.replace(/!$/, "");
// }

// ......................................................................................

// Создайте функцию, которая отвечает на вопрос «Вы играете на банджо?».
// Если ваше имя начинается с буквы «R» или строчной «r», вы играете на банджо!

// Функция принимает имя в качестве единственного аргумента и возвращает одну из следующих строк:

// name + " plays banjo"
// name + " does not play banjo"
// Указанные имена всегда являются допустимыми строками.

// Я САМА!!!!!!!!!!!!!!!!!!!!!!!!!
// function areYouPlayingBanjo(name) {
//   let r = "R";

//   return name.toLowerCase().startsWith(r.toLowerCase())
//     ? name + " plays banjo"
//     : name + " does not play banjo";
//   // if (name.toLowerCase().startsWith(r.toLowerCase())) {
//   //   return name + " plays banjo";
//   // } else{
//   //   return name + " does not play banjo";
//   // }
// }

// ................................................................................................

// В этом ката мы передаем число (n) в функцию.

// Ваш код определит, является ли переданное число четным (или нет).

// Функция должна возвращать либо значение true, либо значение false.

// Числа могут быть положительными или отрицательными, целыми или числами с плавающей точкой.

// Числа с плавающей точкой, не равной нулю, считаются НЕчетными для этого ката.

// function testEven(n) {
//   return n % 2 === 0;
// }

// ..............................................................................................

// Алекс только что получил новый обруч, он ему очень нравится, но он расстроен, потому что его младший брат лучше его.

// Напишите программу, в которой Алекс может ввести ( n), сколько раз обруч сделает оборот, и программа вернет ему ободряющее сообщение:

// Если Алекс наберет 10 или более обручей, верните веревку "Great, now move on to tricks".
// Если он не набрал 10 обручей, верните веревку "Keep at it until you get it".

// function hoopCount (n) {
//   return n >= 10 ? "Great, now move on to tricks" : "Keep at it until you get it";
// }

// .........................................................................................

// Завершите функцию, которая преобразует двоичное число (заданное в виде строки) в десятичное число.

// function binToDec(bin) {
//   return parseInt(bin, 2);
// }

// .........................................................................................................

// Замените все гласные в предложении восклицательными знаками. aeiouAEIOU— гласная.

// function replace(s) {
//   return s.replace(/[aeiouAEIOU]/g, "!");
// }

// ...............................................................................................

// Тимми и Сара думают, что они влюблены, но в том месте, где они живут, они узнают об этом только тогда, когда каждый из них сорвет по цветку. Если у одного из цветков четное количество лепестков, а у другого — нечетное, это значит, что они влюблены.
// Напишите функцию, которая будет принимать количество лепестков каждого цветка и возвращать значение true, если они влюблены, и false, если нет.

// function lovefunc(flower1, flower2) {
// return (flower1 % 2 === 0 && flower2 % 2 === 1) || (flower2 % 2 === 0 && flower1 % 2 === 1) ? true : false;
//   // if (
//   //   (flower1 % 2 === 0 && flower2 % 2 === 1) ||
//   //   (flower2 % 2 === 0 && flower1 % 2 === 1)
//   // ) {
//   //   return true;
//   // } else {
//   //   return false;
//   // }
// }

// ***

// function lovefunc(flower1, flower2){
//   return flower1 % 2 !== flower2 % 2;
// }

// .............................................................................................................

// Дан массив целых чисел.

// Верните массив, где первый элемент — количество положительных чисел, а второй элемент — сумма отрицательных чисел. 0 не является ни положительным, ни отрицательным.

// Если входные данные являются пустым массивом или равны нулю, вернуть пустой массив.

// Пример
// Для ввода [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15]следует вернуть [10, -65].

// function countPositivesSumNegatives(input) {
//   if (input === null || input.length === 0) {
//     return [];
//   }

//   let sumOfPositive = 0;
//   let sumOfNegative = 0;
//   let result = [];
//   input.forEach((element) => {
//     if (element > 0) {
//       sumOfPositive++;
//     } else if (element < 0) {
//       sumOfNegative += element;
//     }
//   });
//   result.push(sumOfPositive, sumOfNegative);
//   return result;
// }

// ................................................................................................

// Дополните функцию квадратной суммы так, чтобы она возводила в квадрат каждое переданное ей число, а затем суммировала результаты.

// Я САМА!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// function squareSum(numbers) {
//   let result = 0;
//   numbers.forEach((element) => {
//     let sumSquared = element * element;
//     result += sumSquared;
//   });
//   return result;
// }

// ......................................................................................................

// У Western Suburbs Croquet Club есть две категории членства: Senior и Open. Они хотели бы, чтобы вы помогли им с формой заявления, которая сообщит потенциальным членам, в какую категорию они будут помещены.

// Чтобы стать пожилым, член должен быть не моложе 55 лет и иметь гандикап больше 7. В этом крокетном клубе гандикапы варьируются от -2 до +26; чем лучше игрок, тем ниже гандикап.

// Вход
// Входные данные будут состоять из списка пар. Каждая пара содержит информацию об одном потенциальном члене. Информация состоит из целого числа для возраста человека и целого числа для инвалидности человека.

// Выход
// Вывод будет состоять из списка строковых значений (на Haskell и C: Openили Senior), указывающих, следует ли отнести соответствующий член к старшей или открытой категории.

// Пример
// input =  [[18, 20], [45, 2], [61, 12], [37, 6], [21, 21], [78, 9]]
// output = ["Open", "Open", "Senior", "Open", "Open", "Senior"]

// function openOrSenior(data) {
//   return data.map((element) => {
//     if (element[0] >= 55 && element[1] > 7) {
//       return "Senior";
//     } else {
//       return "Open";
//     }
//   });
// }

// ....................................................................................................

// Цель этого ката — подсчитать, сколько бутылок виски из беспошлинной торговли вам придется купить, чтобы экономия по сравнению с обычной ценой в магазинах фактически покрыла расходы на ваш отпуск.

// Вам будет указана розничная цена (normPrice, в фунтах стерлингов (£)), скидка беспошлинной торговли (discount, в процентах) и стоимость тура (в фунтах стерлингов).

// Например, если бутылка обычно стоит 10 фунтов стерлингов, а скидка беспошлинной торговли составляет 10%, вы сэкономите 1 фунт стерлингов за бутылку. Если ваш отпуск обойдется в 500 фунтов стерлингов, вам придется купить 500 бутылок, чтобы сэкономить 500 фунтов стерлингов, поэтому ответ, который вы вернете, должен быть 500.

// Другой пример: если бутылка обычно стоит 12 фунтов стерлингов, а скидка беспошлинной торговли составляет 50%, вы сэкономите 6 фунтов стерлингов за бутылку. Если ваш отпуск обойдется в 1000 фунтов стерлингов, вам придется купить 166,66 бутылок, чтобы сэкономить 1000 фунтов стерлингов, поэтому ваш ответ должен быть 166 бутылок.

// Все входные данные будут целыми числами. Верните целое число. Округлите в меньшую сторону.

// function dutyFree(normPrice, discount, hol) {
//   let economy = normPrice * (discount / 100);
//   let numberOfBottles = Math.floor(hol / economy);
//   return numberOfBottles;
// }

// ...........................................................................................

// Grasshopper — отладка синтаксиса функций
// Студент работал над функцией и допустил несколько синтаксических ошибок при кодировании. Помогите им найти свои ошибки и исправить их.

// function main(verb, noun) {
//   return verb + noun;
// }

// ...............................................................................

// Создайте метод, который принимает в качестве входных данных имя, город и штат для приветствия человека. Обратите внимание, что nameэто будет массив, состоящий из одного или нескольких значений, которые должны быть объединены вместе с одним пробелом между ними, а длина массива nameв тестовых случаях будет меняться.

// Пример:

// ['John', 'Smith'], 'Phoenix', 'Arizona'
// Этот пример вернет строкуHello, John Smith! Welcome to Phoenix, Arizona!

// function sayHello(name, city, state) {
//   // console.log(`Hello, ${name[0]} ${name[1]}! Welcome to ${city}, ${state}`)
//   return `Hello, ${name.join(" ")}! Welcome to ${city}, ${state}!`;
// }

// ..............................................................................

// Ваш босс решил сэкономить деньги, купив уцененное программное обеспечение для оптического распознавания символов для сканирования текста старых романов в вашу базу данных. Сначала кажется, что оно нормально распознает слова, но вы быстро замечаете, что оно вставляет много цифр в случайных местах текста.

// Примеры (вход -> выход)
// '! !'                 -> '! !'
// '123456789'           -> ''
// 'This looks5 grea8t!' -> 'This looks great!'
// Ваши измотанные коллеги ждут от вас решения, как взять этот искаженный текст и удалить все цифры. Ваша программа возьмет строку и очистит все числовые символы, а затем вернет строку с пробелами и специальными символами, ~#$%^&!@*():;"'.,?которые останутся нетронутыми

// function stringClean(s) {
//   return s.replace("/d/g", "");
// }

// ..........................................................................................

// Дан массив целых чисел в виде строк и чисел, вернуть сумму значений массива, как если бы все они были числами.
// Ответ дайте в виде числа.

// function sumMix(x) {
//   let sum = 0;
//   x.forEach((element) => {
//     sum += Number(element);
//   });
//   return sum;
// }

// ***

// function sumMix(x) {
//   return x.map((a) => +a).reduce((a, b) => a + b);
// }

// ...................................................................................

// Найти среднее значение

// function findAverage(array) {
//   let sum = 0;
//   array.length === 0
//     ? 0
//     : array.forEach((element) => {
//         sum += element;
//       });
//   let average = sum / array.length;
//   return average;
// }
// // ***
// const findAverage = nums => nums.reduce((a, b) => a + b) / nums.length;

// ..................................................................................

// У вас есть отмеченный наградами сад, и каждый день растениям нужно ровно 40 мм воды. Вы создали отличный фрагмент JavaScript для расчета количества воды, необходимого вашим растениям, приняв во внимание прогнозируемое на день количество дождевой воды. Ваш завистливый сосед взломал ваш компьютер и наполнил ваш код ошибками.
// Ваша задача — отладить код, прежде чем ваши растения погибнут!

// function rainAmount(mm) {
//   if (mm === 40) {
//     return "Your plant has had more than enough water for today!";
//   } else if (mm < 40) {
//     return `You need to give your plant ${40 - mm}mm of water`;
//   } else {
//     return "Your plant has had more than enough water for today!";
//   }
// }

// ..............................................................................................

// Создайте функцию, которая возвращает значение, умноженное на 50 и увеличенное на 6. Если введенное значение является строкой, она должна вернуть «Ошибка».

// function problem(x) {
//   if (typeof x === "string") {
//     return "Error";
//   } else {
//     return x * 50 + 6;
//   }
// }

// .............................................................................................

// Вдохновившись командой разработчиков Vooza, напишите функцию, которая
// принимает имя программиста и
// возвращает количество световых мечей, принадлежащих этому человеку.
// Кстати, единственный человек, у которого есть световые мечи, это Зак. У него их 18, что является потрясающим числом. У всех остальных нет ни одного.

// Примечание : ваша функция должна иметь параметр по умолчанию.

// Например ( Вход -> Выход ):

// "anyone else" --> 0
// "Zach" --> 18

// function howManyLightsabersDoYouOwn(name) {
//   return name === "Zach" ? 18 : 0;
// }

// .........................................................................................

// Филиппу только что исполнилось четыре года, и он хочет узнать, сколько ему будет лет через несколько лет в будущем, например, в 2090 или 3044 году. Его родители не справляются с вычислениями, поэтому они просят вас помочь им, написав программу, которая сможет ответить на бесконечные вопросы Филиппа.

// Ваша задача — написать функцию, которая принимает два параметра: год рождения и год, относительно которого нужно подсчитать годы. Поскольку Филипп становится все более любопытным с каждым днем, он вскоре может захотеть узнать, сколько лет осталось до его рождения, поэтому ваша функция должна работать как с будущими, так и с прошлыми датами.

// Предоставьте вывод в следующем формате: Для дат в будущем: «Вам ... лет». Для дат в прошлом: «Вы родитесь в ... году». Если год рождения совпадает с запрошенным годом, верните: «Вы родились в этом самом году!»

// "..." следует заменить числом, за которым следует один пробел. Помните, что вам нужно учитывать и "год", и "годы", в зависимости от результата.

// function calculateAge(yearOfBirth, referenceНear) {
//   if (referenceНear === yearOfBirth) {
//     return "You were born this very year!";
//   } else if (yearOfBirth < referenceНear) {
//     if (referenceНear - yearOfBirth === 1) {
//       return `You are ${referenceНear - yearOfBirth} year old.`;
//     } else {
//       return `You are ${referenceНear - yearOfBirth} years old.`;
//     }
//   } else if (yearOfBirth > referenceНear) {
//     if (yearOfBirth - referenceНear === 1) {
//       return `You will be born in ${yearOfBirth - referenceНear} year.`;
//     } else {
//       return `You will be born in ${yearOfBirth - referenceНear} years.`;
//     }
//   }
// }

// ***
// function  calculateAge(m, n) {
// 	if(m == n) return 'You were born this very year!';
//   var year = Math.abs(m-n) == 1 ? 'year' : 'years';
//   if(m < n) return "You are "+(n-m)+' '+year+' old.';
//   if(m > n) return "You will be born in "+(-n+m)+' '+year+'.';
// }
//...................................................................................................

// Создай массив, который будет содержать имена всех членов твоей команды. Например: ["Мегатрон", "Звёздный Крик", "Звуковая Волна"].

// Используй метод map, чтобы создать новый массив, который будет содержать строки, начинающиеся с "Делегат: " и включающие имена членов команды. Например: ["Делегат: Мегатрон", "Делегат: Звёздный Крик", "Делегат: Звуковая Волна"].

// Выведи результат в консоль, чтобы все видели, кто на стороне силы!

// const decepticons = ["Мегатрон", "Звёздный Крик", "Звуковая Волна"];
// const numberedDecepticons = decepticons.map((decepticon) => `Делегат: ${decepticon}`)
// console.log(numberedDecepticons);

// ......................................................................................................

// У нас есть массив объектов, каждый из которых представляет Десептикона с его именем и силой.

// const decepticons = [
//   { name: "Мегатрон", strength: 100 },
//   { name: "Звёздный Крик", strength: 80 },
//   { name: "Звуковая Волна", strength: 90 },
//   { name: "Трансформатор", strength: 60 }
// ];
// Используя метод map, создайте новый массив, который будет содержать строки формата: "Имя: Имя, Сила: Сила".
// Затем, используя метод filter, отфильтруйте Десептиконов, у которых сила больше 70.
// В итоге выведите оба массива в консоль: преобразованный массив и отфильтрованный массив.

// let formattedDecepticons = decepticons.map((decepticon) => `Имя ${decepticon.name}, Сила: ${decepticon.strength}`)
// let strongDecepticons = decepticons.filter((decepticon) => decepticon.strength > 70)
// console.log(formattedDecepticons, strongDecepticons);

// .......................................................................................................

// Преобразование: Используй метод map, чтобы создать новый массив строк, где каждая строка будет содержать информацию о автоботе в формате:
// "Имя: [имя], Уровень силы: [уровень], Союз: [союз]".
// Фильтрация: Используй метод filter, чтобы создать новый массив только для автоботов из альянса "Автоботы", у которых уровень силы больше 50.
// Сортировка: Используй метод sort, чтобы отсортировать отфильтрованный массив автоботов по их уровню силы в порядке убывания.

// const autobots = [
//   { name: "Оптимус Прайм", powerLevel: 100, alliance: "Автоботы" },
//   { name: "Бамблби", powerLevel: 70, alliance: "Автоботы" },
//   { name: "Рэтчет", powerLevel: 80, alliance: "Автоботы" },
//   { name: "Мегатрон", powerLevel: 90, alliance: "Десептиконы" },
//   { name: "Звёздный Крик", powerLevel: 60, alliance: "Десептиконы" },
// ];

// let conversion = autobots.map((autobot) => `Имя: ${autobot.name}, Уровень силы: ${autobot.powerLevel}, Союз: ${autobot.alliance}`)
// let filter = autobots.filter((autobot) => autobot.powerLevel > 50 && autobot.alliance === "Автоботы")
// let sort = filter.sort((a, b) => b.powerLevel - a.powerLevel);

// console.log(sort);

// .........................................................................................................

// Определите функцию, которая удаляет дубликаты из массива неотрицательных чисел и возвращает их в качестве результата.
// Порядок последовательности должен оставаться прежним.

// function distinct(a) {
//  let uniqueArray = a.filter(function(item, pos) {
//     return a.indexOf(item) == pos;
// })
// return uniqueArray;
// }
// ***
// function distinct(a) {
//   return [...new Set(a)];
// }
// ......................................................................................................

// Определите метод hello, который выводит returnsсообщение «Hello, Name!» для заданного name, или выводит сообщение «Hello, World!», если имя не указано (или передано как пустая строка).
// Предположим, что nameэто String, и он проверяет наличие опечаток у пользователя, чтобы вернуть имя с первой заглавной буквой (Xxxx).

// function hello(name) {
//   let rename;
//   if (name) {
//     rename = name.toLowerCase();
//   }
//   if (rename) {
//     return `Hello, ${rename.charAt(0).toUpperCase() + rename.slice(1)}!`;
//   } else {
//     return `Hello, World!`;
//   }
// }
// // ***
// const hello = (s) =>
//   `Hello, ${s ? s[0].toUpperCase() + s.slice(1).toLowerCase() : "World"}!`;

// ...........................................................................................

// Напишите функцию, которая принимает два целых числа и возвращает остаток от деления большего значения на меньшее значение.

// Деление на ноль должно вернуть NaN.

// Примеры:
// n = 17
// m = 5
// result = 2 (remainder of `17 / 5`)

// n = 13
// m = 72
// result = 7 (remainder of `72 / 13`)

// n = 0
// m = -1
// result = 0 (remainder of `0 / -1`)

// n = 0
// m = 1

// function remainder(a, b) {
//   return a > b ? a % b : b % a;
// }

// ...........................................................................................

// Ваша задача проста: если xквадрат больше 1000, вернуть It's hotter than the sun!!, иначе вернутьHelp yourself to a honeycomb Yorkie for the glovebox.

// function apple(x) {
//   if (x ** 2 > 1000) {
//     return "It's hotter than the sun!!";
//   } else {
//     return "Help yourself to a honeycomb Yorkie for the glovebox.";
//   }
// }
// ........................................................................

// Принимает строку. Сделать только первые буквы заглавными. Вернуть строку с каждым словом с заглавной буквы

// String.prototype.toJadenCase = function () {
//   return this.split(" ")
//     .map((a) => a.charAt(0).toUpperCase() + a.slice(1))
//     .join(" ");
// };

// .......................................................................................

// В этой игре герой ходит слева направо. Игрок бросает кубик и делает ход на указанное кубиком количество делений два раза .
// Создайте функцию для терминальной игры, которая берет текущую позицию героя и бросок (1-6) и возвращает новую позицию.

// function move (position, roll) {
//   return position + (roll * 2);
// }

// // ***
// const move = (p, r) => p + (r * 2);

// ...................................................................................................

// Создайте класс Ball. Объекты Ball должны принимать один аргумент для «типа мяча» при создании экземпляра.

// Если аргументы не указаны, объекты мяча должны создаваться с «типом мяча» «обычный».

// ball1 = new Ball();
// ball2 = new Ball("super");

// ball1.ballType     //=> "regular"
// ball2.ballType     //=> "super"

// var Ball = function(ballType) {
//   // Если аргумент 'ballType' не указан, то присваиваем значение 'regular'
//   this.ballType = ballType || "regular";
// };

// .................................................................................

// Напишите функцию, которая возвращает строку, в которой имя заменено фамилией.
// Пример (Вход -> Выход)
// "john McClane" --> "McClane john"

// function nameShuffler(str){
//   //разделяем строку
//   const nameArray = str.split(' ');

// // Меняем порядок слов, ставя сначала фамилию, а затем имя
// const swappedName = `${nameArray[1]} ${nameArray[0]}`;

// // Возвращаем новую строку с поменянными местами именем и фамилией
// return swappedName;
// }

// ................................................................................

// Есть массив с некоторыми числами. Все числа равны, кроме одного. Попробуйте найти его!

// findUniq([ 1, 1, 1, 2, 1, 1 ]) === 2
// findUniq([ 0, 0, 0.55, 0, 0 ]) === 0.55
// Гарантируется, что массив содержит не менее 3 чисел.

// Тесты содержат очень большие массивы, поэтому подумайте о производительности.

// function findUniq(arr) {
//   const counts = {};

//   for (const element of arr) {
//       counts[element] = (counts[element] || 0) + 1;
//   }

//   for (const key in counts) {
//       if (counts[key] === 1) {
//           return parseFloat(key); // Если элемент встречается ровно один раз, возвращаем его
//       }
//   }

//   return null; // Если ни один элемент не уникален, возвращаем null
// }

// console.log(findUniq([ 1, 1, 1, 2, 1, 1 ])); // 2
// console.log(findUniq([ 0, 0, 0.55, 0, 0 ])); // 0.55

// ***

// function findUniq(arr) {
//   arr.sort((a,b)=>a-b);
//   return arr[0]==arr[1]?arr.pop():arr[0]
// }

// ....................................................................................

// Вход: Массив элементов

// ["ч","о","л","а"]

// Вывод: строка с разделенными запятыми элементами массива в том же порядке.

// "ч,о,л,а"

// function printArray(array) {
//   return array.toString();
// }

// ........................................................................................

// Это ответвление моего первого ката .

// Вам дана строка, содержащая последовательность символов, разделенных запятыми.

// Напишите функцию, которая возвращает новую строку, содержащую те же последовательности символов, за исключением первого и последнего, но на этот раз разделенные пробелами.

// Если входная строка пуста или удаление первого и последнего элементов приведет к тому, что результирующая строка станет пустой, вернуть пустое значение (представленное как общее значение NULLв примерах ниже).

// Примеры
// "1,2,3"      =>  "2"
// "1,2,3,4"    =>  "2 3"
// "1,2,3,4,5"  =>  "2 3 4"

// ""     =>  NULL
// "1"    =>  NULL
// "1,2"  =>  NULL

// function array(string) {
//   if (string === "" || string.length === 1) {
//     return null;
//   }

//   const elements = string.split(',').slice(1, -1);

//   if(elements.length === 0){
//     return null;
//   }

//   return elements.join(' ');
// }

// ***
// function array(arr) {
//   return arr.split(",").slice(1, -1).join(" ") || null;
// }

// .........................................................................................

// Если　a = 1, b = 2, c = 3 ... z = 26

// Затемl + o + v + e = 54

// иf + r + i + e + n + d + s + h + i + p = 108

// Так что friendshipв два раза сильнее love:-)

// Ваша задача — написать функцию, которая вычисляет значение слова на основе суммы позиций его символов в алфавите.

// Ввод всегда будет состоять только из строчных букв и никогда не будет пустым.

// function wordsToMarks(string) {
//   let sum = 0;
//   let result = string.split("").map((string) => string.charCodeAt(0) - 96);
//   for (let i = 0; i < result.length; i++) {
//     sum += result[i];
//   }
//   return sum;
// }

// // ***
// const wordsToMarks = s => [...s].reduce((res, c) => res += c.charCodeAt() - 96, 0)

// ..................................................................................

//Дана строка произвольной длины с любыми символами ascii. Напишите функцию, которая определит, содержит ли строка целое слово "English".
//Порядок символов важен — строка «abcEnglishdef» является правильной, а «abcnEglishsef» — неправильной.
//Не имеет значения, заглавная или строчная буква — «eNglisH» тоже правильно.
//Возвращаемое значение в виде логического значения: true, если строка содержит «English», false, если не содержит

// function spEng(sentence) {
//   return sentence.toLowerCase().includes("english");
// }

// .......................................................................

// Изограммы. в слове не должна повторяться буква

// function isIsogram(str) {
//   let strLow = str.toLowerCase();
//   let charSet = new Set();

//   for (const char of strLow) {
//     if (charSet.has(char)) {
//       return false;
//     }
//     charSet.add(char);
//   }
//   return true;
// }

//........................................................................

// Учитывая непустой массив целых чисел, вернуть результат умножения значений по порядку. Пример:

// [1, 2, 3, 4] => 1 * 2 * 3 * 4 = 24

// function grow(x) {
//   let result = 1;
//   for (let i = 0; i < x.length; i++) {
//     result *= x[i];
//   }
//   return result;
// }
// // ***
// const grow = (x) => x.reduce((a, b) => a * b);

// ......................................................................

// Вам будет предоставлен массив aи значение x. Все, что вам нужно сделать, это проверить, содержит ли предоставленный массив значение, без использования цикла.

// Массив может содержать числа или строки. xможет быть любым. Возврат, trueесли массив содержит значение, falseесли нет. Со строками вам нужно будет учитывать регистр.

// const check = (a, x) => a.indexOf(x) != -1;
// ***
// Метод .includes() более современный и читабельный по сравнению с .indexOf(). Он также лучше передаёт намерение проверки наличия элемента в массиве.

// const check2 = (a, x) => a.includes(x);
// .........................................................................

// Вам будет дано arrayи limitзначение. Вы должны проверить, что все значения в массиве ниже или равны предельному значению. Если это так, верните true. В противном случае верните false.

// Можно предположить, что все значения в массиве являются числами.

// function smallEnough(a, limit) {
//   const result = a.every((i) => {
//     return i <= limit;
//   });
//   return result;
// }
// ***
// function smallEnough(a, limit){
//   return Math.max(...a) <= limit
// }
// .........................................................................

// В рамках этого ката вам необходимо создать функцию, которая при наличии триплета возвращает индекс числового элемента, который находится между двумя другими элементами.

// Входными данными функции будет массив из трех различных чисел (в Haskell: кортеж).

// Например:

// gimme([2, 3, 1]) => 0
// 2 — это число, которое находится между 1 и 3 , а индекс 2 во входном массиве равен 0 .

// Еще один пример (просто чтобы было понятнее):

// gimme([5, 10, 14]) => 1
// 10 — это число, которое находится между 5 и 14 , а индекс 10 во входном массиве равен 1 .

// function gimme(triplet) {
//     const sortedArray = [...triplet].sort((a, b) => a - b);
//     return triplet.indexOf(sortedArray[1]);
// }

// ./.../....................................................................

// Для данного здания с 3 этажами (пронумерованными 0по 2) имеется 2 лифта (названных «левый» и «правый»), напишите функцию, elevatorпринимающую 3 аргумента (по порядку):

// left- Текущий этаж левого лифта
// right- Текущий этаж правого лифта
// call- Этаж, вызвавший лифт
// Он должен вернуть название лифта, ближайшего к вызванному этажу ( "left"/ "right").

// В случае, если оба лифта находятся на одинаковом расстоянии от вызываемого этажа, выбирайте лифт, расположенный правее.

// Можно предположить, что входные данные всегда будут представлять собой допустимые целые числа в диапазоне от 0 до 2.

// Примеры:

// elevator(0, 1, 0); // => "left"
// elevator(0, 1, 1); // => "right"
// elevator(0, 1, 2); // => "right"
// elevator(0, 0, 0); // => "right"
// elevator(0, 2, 1); // => "right"

// function MathAbs(a, b) {
//   return Math.abs(a - b);
// }

// function elevator(left, right, call) {
//   const leftCall = MathAbs(left, call);
//   const rightCall = MathAbs(right, call);

//   if (leftCall === rightCall) {
//     return "right";
//   }

//   if (leftCall < rightCall) {
//     return "left";
//   }
//   return "right";
// }
// // ***
// function elevator(left, right, call) {
//   return Math.abs(call - left) < Math.abs(call - right) ? "left" : "right";
// }

// .........................................................................

// Испытание:

// Для заданного двумерного массива целых чисел вернуть сглаженную версию массива со всеми целыми числами в отсортированном (возрастающем) порядке.

// Пример:

// Учитывая [[3, 2, 1], [4, 6, 5], [], [9, 7, 8]], ваша функция должна возвращать [1, 2, 3, 4, 5, 6, 7, 8, 9].

// function flattenAndSort(array) {
//   const newArray = array.flat().sort((a, b) => a - b);
//   return newArray;
// }

// ..............................................................................

// function add(a, b) {
//   return a + b;
// }

// function divide(a, b) {
//   return a / b;
// }

// function multiply(a, b) {
//   return a * b;
// }

// function mod(a, b) {
//   // остаток от деления\remainder of division
//   return a % b;
// }

// function exponent(a, b) {
//   // возведение в степень\degree conversion
//   return a ** b;
// }

// function subt(a, b) {
//   return a - b;
// }

// ..........................................................................

// В этом Ката вам будет дана строка, которая может содержать как заглавные, так и строчные буквы, и ваша задача — преобразовать эту строку либо в строку, состоящую только из строчных букв, либо только из заглавных букв на основе:

// вносите как можно меньше изменений.
// если строка содержит одинаковое количество заглавных и строчных букв, преобразовать строку в строчные.
// Например:

// solve("coDe") = "code". Lowercase characters > uppercase. Change only the "D" to lowercase.
// solve("CODe") = "CODE". Uppercase characters > lowecase. Change only the "e" to uppercase.
// solve("coDE") = "code". Upper == lowercase. Change all to lowercase.

// function solve(s) {
//   let letterUpperCase = 0;
//   let letterLowerCase = 0;
//   // Counting uppercase and lowercase letters
//   for (let letter of s) {
//     if (letter === letter.toUpperCase()) {
//       letterUpperCase++;
//     } else if (letter === letter.toLowerCase()) {
//       letterLowerCase++;
//     }
//   }
//   // Determining the result based on counting
//   return letterUpperCase > letterLowerCase ? s.toUpperCase() : s.toLowerCase();
// }

// .....................................................................

// Суммировать все числа заданного массива (cq. list), за исключением самого высокого и самого низкого элемента (по значению, а не по индексу!).

// Самый высокий или самый низкий элемент — это один элемент на каждом краю, даже если их несколько с одинаковым значением.

// Не забывайте о проверке входных данных.

// Пример
// { 6, 2, 1, 8, 10 } => 16
// { 1, 1, 11, 2, 3 } => 6
// Проверка входных данных
// Если вместо массива указано пустое значение ( null, None, Nothing, и т. д. ) или указанный массив является пустым списком или списком, содержащим только один элемент, возвращается .nil10

// function sumArray(array) {
//   // Check if the array is null or has 2 or fewer elements
//   if (!array || array.length <= 2) {
//     // If true, return 0
//     return 0;
//   }

//   // Sort the array in ascending order (from smallest to largest)
//   array.sort((a, b) => a - b);

//   // Remove the first and last elements, then sum the rest
//   return array.slice(1, -1).reduce((acc, curr) => acc + curr, 0);
// }

// ..................................................................

// В этом ката вы создадите функцию, которая принимает список неотрицательных целых чисел и строк и возвращает новый список с отфильтрованными строками.

// filter_list([1,2,'a','b']) == [1,2]
// filter_list([1,'a','b',0,15]) == [1,0,15]
// filter_list([1,2,'aasf','1','123',123]) == [1,2,123]

// const filter_list = (l) => l.filter((i) => typeof i !== "string");

// .....................................................................

// Завершите функцию, которая вычисляет площадь красного квадрата, когда Aв качестве входных данных задана длина дуги окружности. Верните результат, округленный до двух десятичных знаков.

// function squareArea(B) {
//   const r = (2 * B) / Math.PI;
//   return r ** 2;
// }

// ................................................................

// Завершите метод, который принимает массив целых чисел и возвращает одно из следующих значений:

// "yes, ascending"- если числа в массиве отсортированы в порядке возрастания
// "yes, descending"- если числа в массиве отсортированы в порядке убывания
// "no"- в противном случае
// Можно предположить, что массив всегда будет верным и всегда будет один правильный ответ.

// function isSortedAndHow(array) {
//   const copyArrayForAscending = [...array];
//   const copyArrayForDescending = [...array];
//   const ascendingOrder = copyArrayForAscending.sort((a, b) => a - b);
//   const descendingOrder = copyArrayForDescending.sort((a, b) => b - a);

//   if (array.every((value, i) => value === ascendingOrder[i])) {
//     return "yes, ascending";
//   } else if (array.every((value, i) => value === descendingOrder[i])) {
//     return "yes, descending";
//   } else {
//     return "no";
//   }
// }

// ................................................................

// Каждое число должно быть отформатировано так, чтобы оно округлялось до двух знаков после запятой. Вам не нужно проверять, является ли ввод допустимым числом, поскольку в тестах используются только допустимые числа.

// Example:
// 5.5589 is rounded 5.56
// -3.3424 is rounded -3.34

// function twoDecimalPlaces(n) {
//   return Number(n.toFixed(2));
// }

// ................................................................

// Добро пожаловать. В этом ката вам предлагается возвести в квадрат каждую цифру числа и сложить их.

// Например, если мы пропустим 9119 через функцию, то получим 811181, потому что 9 2 — это 81, а 1 2 — это 1. (81-1-1-81)

// Пример №2: Ввод 765 вернет/должен вернуть 493625, потому что 7 2 равно 49, 6 2 равно 36, а 5 2 равно 25. (49-36-25)

// Примечание: функция принимает целое число и возвращает целое число.

// function squareDigits(num) {
//   const numToStr = String(num);
//   const strToArr = numToStr.split("");
//   const squaring = strToArr.map((num) => num ** 2);
//   const squaringToStr = squaring.join("");
//   const squaringToStrToNum = Number(squaringToStr);

//   return squaringToStrToNum;
// }

// .............................................................

// Массивы JavaScript поддерживают функцию фильтра (начиная с JavaScript 1.6).
// Используйте функцию фильтрации для выполнения заданной функции.
// Решение будет выглядеть следующим образом: getEvenNumbers([2,4,5,6]) // should == [2,4,6]

// const getEvenNumbers = (numbersArray) =>
//   numbersArray.filter((num) => !(num % 2));

// .............................................................

// Возвращает количество гласных в заданной строке.
// Мы будем считать a, e, i, o, uгласными для этого Ката (но не y).
// Входная строка будет состоять только из строчных букв и/или пробелов.

// function getCount(str) {
//     let convertToStrToArr = str.split("");
//     const vowels = "aeiou";
//     let countingVowels = convertToStrToArr.filter((w) => vowels.includes(w));
//     return countingVowels.length;
// }
//
// console.log(getCount("a e i o u"));

// ...........................................................................

// Напишите функцию, которая принимает fightстроку, состоящую только из маленьких букв, и возвращает, кто победил в битве. Когда побеждает левая сторона, возвращайте Left side wins!, когда побеждает правая сторона, возвращайте Right side wins!, в противном случае возвращайте Let's fight again!.

// Буквы левой стороны и их сила:

//  w - 4
//  p - 3
//  b - 2
//  s - 1
// Буквы правой стороны и их сила:

//  m - 4
//  q - 3
//  d - 2
//  z - 1
// Остальные буквы не имеют силы и являются лишь жертвами.

// Пример
// alphabetWar("z");        //=> Right side wins!
// alphabetWar("zdqmwpbs"); //=> Let's fight again!
// alphabetWar("zzzzs");    //=> Right side wins!
// alphabetWar("wwwwwwz");  //=> Left side wins!

// function alphabetWar(fight){
//   const leftPower = { w: 4, p: 3, b: 2, s: 1 };
//   const rightPower = { m: 4, q: 3, d: 2, z: 1 };

//   let leftScore = 0;
//   let rightScore = 0;

//   for (let i = 0; i < fight.length; i++){
//     const letter = fight[i]

//     if (leftPower[letter]){
//       leftScore += leftPower[letter]
//     }

//      if (rightPower[letter]){
//       rightScore += rightPower[letter]
//     }

//   }

//     if (leftScore  > rightScore) {
//       return "Left side wins!";
//     } else if (rightScore > leftScore ) {
//       return "Right side wins!";
//     } else {
//       return "Let's fight again!";
//     }

// }
// .......................................................................

// Чтобы найти объем (в кубических сантиметрах) прямоугольного параллелепипеда, используйте формулу:

// volume = Length * Width * Height

// Но кто-то забыл вести надлежащий учет, поэтому у нас есть только объем и длина одной стороны!

// Вам предстоит выяснить, равны ли стороны прямоугольного параллелепипеда (= является ли он кубом).

// Верните, trueесли прямоугольный параллелепипед может иметь равные стороны, falseв противном случае верните.

// Возврат falseтакже для недопустимых чисел (например, объем или сторона меньше или равна 0).

// Примечание: сторона будет целым числом.

// function cubeChecker(volume, side) {
//     if (volume <= 0 || side <= 0) {
//         return false;
//     } else {
//         const cubeVolume = side ** 3;
//         return cubeVolume === volume;
//     }
// }

// ......................................................................

// Приведенный код должен заменить все точки .в указанной строке strна тире.-

// Но он не работает должным образом.

// Задача
// Исправьте ошибку, чтобы мы все смогли уйти домой пораньше.

// Примечания
// Строка strникогда не будет нулевой.

// var replaceDots = function (str) {
//     return str.replace(/\./g, "-");
// };

// ........................................................................

// Проверьте, содержит ли строка одинаковое количество символов 'x' и 'o'. Метод должен возвращать логическое значение и быть нечувствительным к регистру. Строка может содержать любой символ.

// Примеры ввода/вывода:

// XO("ooxx") => true
// XO("xooxx") => false
// XO("ooxXm") => true
// XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
// XO("zzoo") => false

// function XO(str) {
//     let strToArr = str.toLowerCase().split("")
//
//     let x = strToArr.filter((elem) => elem === "x");
//     let o = strToArr.filter((elem) => elem === "o");
//
//     return o.length === x.length ? true : false;
// }

// .......................................................................

//Напишите функцию, которая принимает массив строк в качестве аргумента и возвращает отсортированный массив, содержащий те же строки, упорядоченные от самой короткой к самой длинной.

// Например, если этот массив был передан в качестве аргумента:

// ["Telescopes", "Glasses", "Eyes", "Monocles"]

// Ваша функция вернет следующий массив:

// ["Eyes", "Glasses", "Monocles", "Telescopes"]

// Все строки в массиве, переданном вашей функции, будут иметь разную длину, поэтому вам не придется решать, как упорядочить несколько строк одинаковой длины.

// function sortByLength(array) {
//
//   let sortArray = array.sort((a, b) => a.length - b.length);
//   return sortArray;
// }

// ......................................................................................
// function remove(s, n) {
//     const sToStr = s.split(""); // Преобразуем строку в массив символов
//
//     for (let i = 0; i < n; i++) { // Цикл для удаления n восклицательных знаков
//         const index = sToStr.indexOf("!"); // Найти первый '!'
//         if (index !== -1) { // Если '!' найден
//             sToStr.splice(index, 1); // Удалить найденный '!'
//         } else {
//             break; // Если '!' больше нет, выходим из цикла
//         }
//     }
//
//     return sToStr.join(""); // Собираем массив обратно в строку
// }

//..........................................................

// Напишите функцию, которая возвращает общую площадь поверхности и объем коробки в виде массива:[area, volume]

// function getSize(width, height, depth) {
//     let area = 2 * (width * height + height * depth + width * depth);
//     let volume = width * height * depth
//
//     return [area, volume]
// }

//........................................................................

// Создайте функцию, которая конвертирует доллары США (USD) в китайские юани (CNY). Входные данные — это сумма в долларах США в виде целого числа, а выходные данные должны быть строкой, которая указывает сумму в юанях, за которой следует «китайские юани».
//
// Примеры (Вход -> Выход)
// 15  -> '101.25 Chinese Yuan'
// 465 -> '3138.75 Chinese Yuan'
// Курс обмена, который вы должны использовать, составляет 6,75 CNY за 1 USD. Все числа должны быть представлены в виде строки с 2 десятичными знаками. (например, "21.00", а НЕ "21.0" или "21")

// const usdcny = (usd) => (usd * 6.75).toFixed(2) + " Chinese Yuan";

//........................................................................

// дано число, надо сложить все числа от нуля до этого числа

// var SequenceSum = (function () {
//     function SequenceSum() {}
//
//     SequenceSum.showSequence = function (count) {
//         let result = [];
//
//         if (count < 0) {
//             return `${count}<0`;
//         }
//
//         if (count === 0) {
//             return '0=0';
//         }
//
//         for (let i = 0; i <= count; i++) {
//             result.push(i);
//         }
//
//         let sum = result.reduce((a, b) => a + b);
//         let numbersString = result.join("+");
//
//         return `${numbersString} = ${sum}`;
//     };
//
//     return SequenceSum;
// })();

//...................................................................

// Вам будет дана непустая строка. Ваша задача — вернуть средний символ(ы) строки.
//
//     Если длина строки нечетная, вернуть средний символ.
//     Если длина строки четная, вернуть 2 средних символа.
//     Примеры:
// "test" --> "es"
// "testing" --> "t"
// "middle" --> "dd"
// "A" --> "A"

// function getMiddle(s) {
//     debugger
//     let sLength = s.length;
//     if (sLength % 2 === 0) {
//         let start = sLength / 2 - 1
//         let end = sLength / 2 + 1
//
//         return s.substring(start, end)
//     } else {
//         let a = Math.floor(sLength / 2)
//         let b = Math.ceil(sLength / 2)
//         return s.substring(a, b)
//     }
// }
//
// getMiddle("alina")

//...................................................................

// Ваша цель — вернуть таблицу умножения number, которая всегда является целым числом от 1 до 10.
//
// Например, таблица умножения (строка) number == 5выглядит следующим образом:
//
//     1 * 5 = 5
// 2 * 5 = 10
// 3 * 5 = 15
// 4 * 5 = 20
// 5 * 5 = 25
// 6 * 5 = 30
// 7 * 5 = 35
// 8 * 5 = 40
// 9 * 5 = 45
// 10 * 5 = 50
// P.S. Вы можете использовать \nстроку для перехода на следующую строку.
//
//     Примечание: между строками должны быть добавлены новые строки, но в конце не должно быть завершающего нового слова. Если вы не уверены в формате, посмотрите на примеры тестов.

// function multiTable(number) {
//     let arrToString = []
//
//     for (let i = 1; i <= 10; i++) {
//         let strValue = i * number;
//         let str = `${i} * ${number} = ${strValue}`;
//         arrToString.push(str);
//     }
//
//     return arrToString.join(`\n`)
// }

//....................................................................

// Напишите небольшую функцию, которая возвращает значения массива, которые не являются нечетными.

// Все значения в массиве будут целыми числами. Верните правильные значения в том порядке, в котором они указаны.

// const noOdds = (values) => values.filter(n => n % 2 === 0);

//....................................................................

// Какой-то очень забавный веб-разработчик выдал вам последовательность чисел из своего ответа API в виде последовательности строк !
//     Вам необходимо привести весь массив к правильному типу.
//     Создайте функцию, которая принимает в качестве параметра последовательность чисел, представленных в виде строк, и выводит последовательность чисел.
//     то есть: ["1", "2", "3"]к[1, 2, 3]
//
// Обратите внимание, что вы также можете получать поплавки.

// function toNumberArray(stringarray) {
//     return stringarray.map(i => Number(i));
// }

// console.log(toNumberArray(["1", "2", "3"]))

// ...........................................................................

// Ваша команда пишет новый модный текстовый редактор, и вам поручено реализовать нумерацию строк.
//     Напишите функцию, которая принимает список строк и возвращает каждую строку, снабженную правильным числом.
//     Нумерация начинается с 1. Формат: n: string. Обратите внимание на двоеточие и пробел между ними.
//     Примеры: (Вход -> Выход)
//     [] --> []
//     ["a", "b", "c"] --> ["1: a", "2: b", "3: c"]

function number(array) {
    if (array === []) {
        return array;
    }
    return array.map((n, i) => `${i + 1}: ${n}`)
}

// ...........................................................................

// Функция объединения строк
// Создайте, функцию с именем combineNames/ combine_names/, CombineNames которая принимает два параметра (имя и фамилию). Функция должна возвращать полное имя.
//
//     Пример:
//
// С "James"именем и "Stevens"фамилией следует вернуть"James Stevens"

// const combineNames = (firstName, lastName) => `${firstName} ${lastName}`;

// ...........................................................................

// Завершите функцию, которая получает в качестве входных данных строку и выдает выходные данные в соответствии со следующей таблицей:
//
//     Вход	Выход
// "Джаброни"	«Патрон Текила»
// «Школьный консультант»	«Все, что содержит алкоголь»
// "Программист"	«Хипстерское крафтовое пиво»
// «Член байкерской банды»	"Самогон"
// "Политик"	«Ваши налоговые доллары»
// "Рэппер"	"Кристалл"
// что-нибудь еще	"Пиво"
// Примечание: все остальное является случаем по умолчанию: если входные данные функции не являются ни одним из значений в таблице, то возвращаемое значение должно быть "Beer".
//
//     Убедитесь, что вы охватываете случаи, когда некоторые слова не отображаются с правильной регистрацией. Например, ввод "pOLitiCIaN"должен по-прежнему возвращать "Your tax dollars".

//     function getDrinkByProfession(param) {
//     let paramNorm = param.toLowerCase();
//
//     if (paramNorm === "jabroni") {
//         return "Patron Tequila";
//     } else if (paramNorm === "school counselor") {
//         return "Anything with Alcohol";
//     } else if (paramNorm === "programmer") {
//         return "Hipster Craft Beer";
//     } else if (paramNorm === "bike gang member") {
//         return "Moonshine";
//     } else if (paramNorm === "politician") {
//         return "Your tax dollars";
//     } else if (paramNorm === "rapper") {
//         return "Cristal";
//     } else {
//         return "Beer";
//     }
// }

//.............................................................................

// Задача
// Данную строку strперевернуть и исключить все неалфавитные символы.
//
//     Пример
// Для str = "krishan", вывод должен быть "nahsirk".
//
//     Для str = "ultr53o?n", вывод должен быть "nortlu".
//
//     Ввод/вывод
//     [input]нитьstr
// Строка состоит из строчных латинских букв, цифр и символов.
//
//     [output]строка

// function reverseLetter(str) {
//     const alphabet = [
//         'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
//         'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
//         'u', 'v', 'w', 'x', 'y', 'z'
//     ]
//
//     const strSplit = str.split('')
//     const filteredStr = strSplit.filter(i => alphabet.includes(i))
//     return filteredStr.reverse().join('');
// }

//.............................................................................

// Вернуть тип суммы двух аргументов

// function typeOfSum(a, b) {
//     let sum = a + b
//     return typeof sum
// }

//.............................................................................

// В этом ката мы создадим функцию для проверки задержки менструации.
//
//     Наша функция будет принимать три параметра:
//
//     last - Объект Date с датой последнего периода
//
// сегодня - объект Date с датой проверки
//
// cycleLength — целое число, представляющее продолжительность цикла в днях.
//
//     Верните true, если количество дней, прошедших с прошлого по сегодняшний день, больше cycleLength. В противном случае верните false.
//

function periodIsLate(last, today, cycleLength) {
    let qualityDay = today - last
    const millisecondsInADay = 1000 * 60 * 60 * 24;
    let realDay = qualityDay / millisecondsInADay;
    if (realDay > cycleLength) {
        return true
    } else {
        return false
    }
}

//.............................................................................

// Американцы — странные люди: в их зданиях первый этаж на самом деле является цокольным, а 13-го этажа нет (из-за суеверия).
//
// Напишите функцию, которая по указанному полу в американской системе возвращает пол в европейской системе.
//
//     С заменой 1-го этажа на первый этаж и удалением 13-го этажа цифры смещаются вниз, чтобы занять их место. В случае выше 13 они смещаются вниз на два, потому что под ними есть два пропущенных числа.
//
// Подвалы (негативы) остаются такими же, как и на универсальном уровне.
//
// Примеры
// 1  =>  0
// 0  =>  0
// 5  =>  4
// 15  =>  13
// -3  =>  -3

function getRealFloor(n) {
    if (n <= 0) {
        return n
    }

   return n < 13 ? n -1 : n - 2
}

//.............................................................................

// Давайте представим, что у нас есть популярная онлайновая RPG. Игрок начинает с 0 баллов в классе E5. A1 — это наивысший уровень, которого может достичь игрок.
//     Теперь предположим, что игрок хочет подняться до класса E4. Для этого игроку необходимо набрать не менее 100 очков, чтобы попасть в квалификационный этап.
//     Напишите скрипт, который будет проверять, набрал ли игрок не менее 100 очков в своем классе. Если да, то он переходит в квалификационный этап.
//     В этом случае мы возвращаем, "Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.".
//     В противном случае вернитесь False/false(в соответствии с используемым языком).

function playerRankUp (points) {
  if(points >= 100){
      return "Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up."
  } else {
      return false
  }
}

//.............................................................................

// Компания, в которой вы работаете, только что получила контракт на создание платежного шлюза. Чтобы помочь продвинуться вперед, вы вызвались создать функцию, которая будет принимать число с плавающей точкой и возвращать сумму, форматированную в долларах и центах.
// 39.99 becomes $39.99
// Остальная часть вашей команды позаботится о том, чтобы аргумент был очищен перед передачей в вашу функцию, хотя вам придется учитывать добавление конечных нулей, если они отсутствуют (хотя вам не придется беспокоиться о висячей точке).
// Примеры:
//     3 needs to become $3.00
// 3.1 needs to become $3.10

function formatMoney(amount){
    return `$${amount.toFixed(2)}`;
}

//.............................................................................

// Для этой задачи вам необходимо создать программу, которая говорит, кто съел последнее печенье. Если входные данные — строка, то «Зак» съел печенье. Если входные данные — число с плавающей точкой или целое число, то «Моника» съела печенье. Если входные данные — что-то еще, то «собака» съела печенье. Способ возврата утверждения: «Кто съел последнее печенье? Это был (имя)!»
// Пример: Ввод = "привет" --> Вывод = "Кто съел последнее печенье? Это был Зак! (Причина, по которой вы возвращаете Зака, заключается в том, что ввод представляет собой строку)

function cookie(x){
  if (typeof x === "string") {
      return `Who ate the last cookie? It was Zach!`
  } else if (typeof x === "number") {
      return `Who ate the last cookie? It was Monica!`
  } else {
      return `Who ate the last cookie? It was the dog!`
  }
}

//.............................................................................

// https://www.codewars.com/kata/583f158ea20cfcbeb400000a/train/javascript

// Даны два числа и арифметический оператор (его имя в виде строки), вернуть результат применения этого оператора к двум числам.
//
//     aи bоба будут положительными целыми числами и aвсегда будут первым числом в операции, и bвсегда вторым.
//
//     Четыре оператора: «сложение», «вычитание», «деление», «умножение».
//
// Несколько примеров: (Вход1, Вход2, Вход3 --> Выход)
//
// 5, 2, "add"      --> 7
// 5, 2, "subtract" --> 3
// 5, 2, "multiply" --> 10
// 5, 2, "divide"   --> 2.5
// Попробуйте сделать это без использования операторов if!

function arithmetic(a, b, operator){
 switch (operator) {
     case "add":
        return  a + b
     break;
        case "subtract":
            return  a - b
     break;
            case "multiply":
                return  a * b
     break
     case "divide":
         return  a / b
     break;
 }
}

function correctPolishLetters (string) {

//.............................................................................

//     There are 32 letters in the Polish alphabet: 9 vowels and 23 consonants.
//
//         Your task is to change the letters with diacritics:
//
//     ą -> a,
//         ć -> c,
//         ę -> e,
//         ł -> l,
//         ń -> n,
//         ó -> o,
//         ś -> s,
//         ź -> z,
//         ż -> z
//     and print out the string without the use of the Polish letters.
//
//         For example:
//
//         "Jędrzej Błądziński"  -->  "Jedrzej Bladzinski"

    const polishToLatin = {
        "ą": "a",
        "ć": "c",
        "ę": "e",
        "ł": "l",
        "ń": "n",
        "ó": "o",
        "ś": "s",
        "ź": "z",
        "ż": "z"
    };
return string.split("").map(w => polishToLatin[w] ?  polishToLatin[w] : w).join('')
}

//.............................................................................

// Oh no! Timmy hasn't followed instructions very carefully and forgot how to use the new String Template feature, Help Timmy with his string template so it works as he expects!

function buildString(...template){
    return `I like ${template.join(', ')}!`;
}

//.............................................................................

// В этом ката вам нужно просто определить, является ли данный год високосным или нет. Если вы не знаете правил, вот они:
//
//     Годы, делящиеся на 4, являются високосными.
//     но годы, делящиеся на 100, не являются високосными,
//     но годы, делящиеся на 400, являются високосными.
//     Проверенные годы находятся в диапазоне 1600 ≤ year ≤ 4000.

function isLeapYear(year) {
  if(year % 400 === 0) {
    return true;
  } else if (year % 100 === 0) {
      return false;
  } else if(year % 4 === 0) {
      return true
  }
  return false;
}

//.............................................................................


